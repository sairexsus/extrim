<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>EXTRIM Miner — готово</title>
<style>
  :root{
    --accent: #ffd700;
    --dark: rgba(0,0,0,0.6);
  }
  html,body{height:100%;margin:0;font-family:Inter,Segoe UI,Arial, sans-serif;background:#111;}
  body{
    background: url('extrim.png') no-repeat center center fixed;
    background-size: cover;
    color:#fff;
    display:flex;
    align-items:flex-start;
    justify-content:center;
    padding:24px;
    box-sizing:border-box;
  }
  /* затемнённый фон для читаемости */
  body::before{
    content:""; position:fixed; inset:0;
    background:var(--dark); backdrop-filter:blur(4px);
    z-index:0;
  }

  .app{
    z-index:1;
    width:100%;
    max-width:980px;
    display:flex;
    flex-direction:column;
    align-items:center;
  }

  header{
    width:100%;
    display:flex;
    align-items:center;
    justify-content:space-between;
    gap:12px;
    margin-bottom:16px;
  }
  h1{margin:0;font-size:28px; font-weight:700; text-shadow:0 2px 8px rgba(0,0,0,0.6);}
  .top-controls{
    position:relative;
    display:flex;
    align-items:center;
    gap:8px;
  }
  .mode-btn{
    padding:9px 16px;
    border-radius:999px;
    border:none;
    font-weight:700;
    cursor:pointer;
    background:rgba(255,215,0,0.85);
    color:#000;
    box-shadow:0 6px 18px rgba(0,0,0,0.4);
  }
  .mode-btn.inactive{
    background:rgba(255,255,255,0.12);
    color:#fff;
    box-shadow:none;
  }

  /* центр — поле */
  .center{
    display:flex;
    flex-direction:column;
    align-items:center;
    gap:14px;
    width:100%;
  }

  .grid{
    display:grid;
    grid-template-columns:repeat(8,72px);
    grid-auto-rows:72px;
    gap:10px;
    background:rgba(0,0,0,0.45);
    padding:18px;
    border-radius:14px;
    box-shadow:0 10px 40px rgba(0,0,0,0.6);
  }

  .cell{
    background:linear-gradient(#ffffff,#f2f2f2);
    border-radius:12px;
    border:2px solid rgba(0,0,0,0.15);
    display:flex;
    align-items:center;
    justify-content:center;
    font-weight:800;
    color:#111;
    font-size:18px;
    user-select:none;
    cursor:pointer;
    box-shadow:0 4px 8px rgba(0,0,0,0.2);
    transform:translateZ(0);
    transition:transform .12s ease, box-shadow .12s ease, background .12s ease;
  }
  .cell:hover{ transform:translateY(-6px) scale(1.03); box-shadow:0 12px 20px rgba(0,0,0,0.35);}
  .cell.opened{ background:#efefef; cursor:default; transform:none; box-shadow:0 2px 6px rgba(0,0,0,0.15); }
  .cell.bomb{ background:#c62828; color:white; font-size:22px; box-shadow:0 0 10px #ff3d3d; }
  .cell.reward{ color:#0b833e; text-shadow:0 0 6px rgba(75,175,90,0.25); }

  .controls {
    display:flex;
    gap:12px;
    align-items:center;
    justify-content:center;
    margin-top:6px;
  }
  #upgradeBtn{
    padding:12px 26px;
    border-radius:26px;
    border:none;
    background:linear-gradient(45deg,var(--accent),#ffab00);
    color:#000;
    font-weight:800;
    cursor:pointer;
    box-shadow:0 10px 30px rgba(255,200,0,0.18);
    display:inline-block;
  }
  #upgradeBtn[disabled]{
    opacity:.45; cursor:not-allowed; box-shadow:none;
  }

  .info-line{
    margin-top:10px;
    color:rgba(255,255,255,0.85);
    font-size:14px;
  }

  /* Рулетка оверлей */
  #rouletteOverlay{
    position:fixed; inset:0; display:flex; align-items:center; justify-content:center; z-index:9999;
    background:rgba(0,0,0,0.7); visibility:hidden; opacity:0; transition:opacity .25s ease;
  }
  #rouletteOverlay.show{ visibility:visible; opacity:1; }
  #rouletteBox{
    width:360px; max-width:92vw; background:linear-gradient(#161616,#222); border-radius:12px; padding:18px; text-align:center;
    box-shadow:0 30px 80px rgba(0,0,0,0.7);
  }
  #rouletteCanvas{ width:300px; height:300px; display:block; margin:0 auto; border-radius:50%; background:#111; }
  #rouletteArrow{
    width:0;height:0;border-left:14px solid transparent;border-right:14px solid transparent;border-bottom:26px solid var(--accent);
    margin:-12px auto 8px; filter:drop-shadow(0 4px 8px rgba(0,0,0,0.6));
  }
  #rouletteResult{ margin-top:12px; font-weight:800; font-size:18px; color:#fff; min-height:26px;}
  .close-btn{
    margin-top:12px; padding:10px 18px; border-radius:10px; border:none; font-weight:700; cursor:pointer; background:var(--accent);
  }

  /* адаптив */
  @media (max-width:760px){
    .grid{grid-template-columns:repeat(8,44px); grid-auto-rows:44px; gap:6px; padding:12px;}
    .cell{font-size:14px;}
    #rouletteCanvas{width:220px;height:220px;}
  }

</style>
</head>
<body>
  <div class="app">
    <header>
      <h1>EXTRIM Miner</h1>
      <div class="top-controls">
        <button id="btnTwitch" class="mode-btn">Twitch</button>
        <button id="btnYouTube" class="mode-btn inactive">YouTube</button>
      </div>
    </header>

    <div class="center">
      <div id="status" class="info-line">Режим: <span id="modeText">Twitch (максимум 5000)</span></div>
      <div class="grid" id="grid" aria-hidden="false"></div>

      <div class="controls">
        <button id="upgradeBtn" disabled>Улучшить награду</button>
      </div>
      <div class="info-line" id="hint">Нажми на любую клетку — откроются все суммы, бомбы остаются скрытыми до клика.</div>
    </div>
  </div>

  <!-- Рулетка -->
  <div id="rouletteOverlay" role="dialog" aria-hidden="true">
    <div id="rouletteBox">
      <div id="rouletteArrow"></div>
      <canvas id="rouletteCanvas" width="300" height="300"></canvas>
      <div id="rouletteResult"></div>
      <button id="closeRoulette" class="close-btn">Закрыть</button>
    </div>
  </div>

<script>
/* ===========================================================
   Настройки и логика игры
   =========================================================== */

const gridEl = document.getElementById('grid');
const btnTwitch = document.getElementById('btnTwitch');
const btnYouTube = document.getElementById('btnYouTube');
const modeText = document.getElementById('modeText');
const upgradeBtn = document.getElementById('upgradeBtn');
const statusLine = document.getElementById('status');
const rouletteOverlay = document.getElementById('rouletteOverlay');
const rouletteCanvas = document.getElementById('rouletteCanvas');
const rouletteResult = document.getElementById('rouletteResult');
const closeRoulette = document.getElementById('closeRoulette');

let mode = 'twitch'; // 'twitch' или 'youtube'
let board = []; // массив 64 объектов {type:'bomb'|'reward', value:number, opened:boolean}
let firstClickDone = false;
let currentCellIndex = null;
let currentValue = 0;
const BOMBS_COUNT = 10;
const SIZE = 64; // 8x8

// Награды для режимов
const twitchRewards = [
  {value:1000, weight:40},
  {value:1500, weight:30},
  {value:2000, weight:15},
  {value:2500, weight:8},
  {value:5000, weight:5},
];

const youtubeRewards = [
  {value:1000, weight:35},
  {value:1500, weight:25},
  {value:2000, weight:15},
  {value:2500, weight:10},
  {value:5000, weight:8},
  {value:10000, weight:7},
];

// Вспомогательная — выбор по весам
function weightedRandom(items){
  const total = items.reduce((s,i)=>s+i.weight,0);
  let r = Math.random()*total;
  for(const it of items){
    if(r < it.weight) return it.value;
    r -= it.weight;
  }
  return items[items.length-1].value;
}

// Генерация доски — кладём бомбы и награды, гарантируем 1 макс.
function generateBoard(){
  board = new Array(SIZE).fill(null);
  // выберем BOMBS_COUNT уникальных позиций
  const idxs = [...Array(SIZE).keys()];
  shuffleArray(idxs);

  const bombPos = new Set(idxs.slice(0,BOMBS_COUNT));
  // присваиваем
  for(let i=0;i<SIZE;i++){
    if(bombPos.has(i)){
      board[i] = {type:'bomb', value:0, opened:false};
    } else {
      board[i] = {type:'reward', value:0, opened:false};
    }
  }
  // теперь распределим значения наград
  const rewardList = (mode==='twitch') ? twitchRewards : youtubeRewards;

  // сначала поставим гарантированную максимальную сумму на случайной не-бомбе
  const maxVal = (mode==='twitch')?5000:10000;
  const freeIdx = [];
  for(let i=0;i<SIZE;i++) if(board[i].type==='reward') freeIdx.push(i);
  shuffleArray(freeIdx);
  if(freeIdx.length>0){
    board[freeIdx[0]].value = maxVal;
  }

  // для остальных reward cell — заполним весами
  for(let i=0;i<SIZE;i++){
    if(board[i].type==='reward' && board[i].value===0){
      board[i].value = weightedRandom(rewardList);
    }
  }

  firstClickDone = false;
  currentCellIndex = null;
  currentValue = 0;
  renderBoardCollapsed();
  upgradeBtn.disabled = true;
  upgradeBtn.removeAttribute('data-current');
}

// Помещаем скрытый рендер (пустые плитки) — пока не раскрыто
function renderBoardCollapsed(){
  gridEl.innerHTML = '';
  for(let i=0;i<SIZE;i++){
    const cell = document.createElement('div');
    cell.className = 'cell';
    cell.dataset.index = i;
    cell.innerHTML = ''; // пусто
    cell.addEventListener('click', onCellClick);
    gridEl.appendChild(cell);
  }
}

// Полное раскрытие сумм (показываем числа, но бомбы остаются скрыты)
function revealAllSums(){
  const cells = gridEl.children;
  for(let i=0;i<SIZE;i++){
    const info = board[i];
    const el = cells[i];
    if(info.type==='reward'){
      el.classList.add('opened','reward');
      animateCellNumber(el, info.value);
    } else {
      // бомбы остаются закрыты (пустыми)
      el.classList.remove('opened');
      el.textContent = '';
    }
    // mark opened state logically? we only visually show sums
    // board[i].opened stays false until clicked
  }
}

// Клике по ячейке
function onCellClick(e){
  const idx = Number(e.currentTarget.dataset.index);
  if(board[idx].opened) return; // уже окончательно открыто (после бомбы или уже выбранная)
  // если первый клик — раскрываем все суммы (как просил)
  if(!firstClickDone){
    firstClickDone = true;
    revealAllSums();
  }
  // теперь обработаем клик по конкретной ячейке
  const info = board[idx];
  const el = e.currentTarget;
  if(info.type === 'bomb'){
    // показываем взрыв
    el.classList.add('bomb','opened');
    el.textContent = '💣';
    board[idx].opened = true;
    // сбрасываем текущую награду
    currentCellIndex = null;
    currentValue = 0;
    upgradeBtn.disabled = true;
    upgradeBtn.removeAttribute('data-current');
    return;
  } else {
    // показываем reward (если еще не показан как opened)
    el.classList.add('opened','reward');
    animateCellNumber(el, info.value);
    board[idx].opened = true;
    currentCellIndex = idx;
    currentValue = info.value;
    upgradeBtn.disabled = false;
    upgradeBtn.setAttribute('data-current', String(currentValue));
  }
}

// плавная анимация числа в ячейке
function animateCellNumber(el, target){
  let cur = parseInt(el.textContent.replace(/\D/g,'')) || 0;
  const steps = 24;
  const step = Math.max(1, Math.round((target - cur)/steps));
  const id = setInterval(()=>{
    cur += step;
    if(cur >= target){
      el.textContent = target;
      clearInterval(id);
    } else {
      el.textContent = cur;
    }
  }, 30);
}

// утилита
function shuffleArray(a){
  for(let i=a.length-1;i>0;i--){
    const j = Math.floor(Math.random()*(i+1));
    [a[i],a[j]]=[a[j],a[i]];
  }
}

/* ============= переключение режима ============= */
btnTwitch.addEventListener('click', ()=>{
  if(mode==='twitch') return;
  mode='twitch';
  btnTwitch.classList.remove('inactive');
  btnYouTube.classList.add('inactive');
  modeText.textContent = 'Twitch (максимум 5000)';
  generateBoard();
});
btnYouTube.addEventListener('click', ()=>{
  if(mode==='youtube') return;
  mode='youtube';
  btnYouTube.classList.remove('inactive');
  btnTwitch.classList.add('inactive');
  modeText.textContent = 'YouTube (максимум 10000)';
  generateBoard();
});

/* ============== Upgrade -> рулетка =============== */

upgradeBtn.addEventListener('click', ()=>{
  if(currentCellIndex===null) return;
  // берем текущую сумму
  const info = board[currentCellIndex];
  if(!info || info.type!=='reward') return;
  // открываем оверлей рулетки
  openRoulette(info, currentCellIndex);
});

/* ------------- рулетка (плавное вращение) ----------- */

const ctx = rouletteCanvas.getContext('2d');
const R = rouletteCanvas.width/2;
const GREEN_ANGLE = 120; // degrees of green sector
const RED_ANGLE = 360 - GREEN_ANGLE;
// draw static wheel initially
function drawWheel(angleOffset=0){
  const cx = rouletteCanvas.width/2;
  const cy = rouletteCanvas.height/2;
  ctx.clearRect(0,0,rouletteCanvas.width,rouletteCanvas.height);
  ctx.save();
  ctx.translate(cx,cy);
  ctx.rotate((angleOffset*Math.PI)/180);
  // green sector
  ctx.beginPath();
  ctx.moveTo(0,0);
  ctx.arc(0,0,R, degToRad(0), degToRad(GREEN_ANGLE));
  ctx.closePath();
  ctx.fillStyle = '#4caf50';
  ctx.fill();
  // red sector
  ctx.beginPath();
  ctx.moveTo(0,0);
  ctx.arc(0,0,R, degToRad(GREEN_ANGLE), degToRad(360));
  ctx.closePath();
  ctx.fillStyle = '#f44336';
  ctx.fill();
  // border
  ctx.beginPath();
  ctx.arc(0,0,R,0,Math.PI*2);
  ctx.lineWidth=4;
  ctx.strokeStyle='#ffd700';
  ctx.stroke();
  ctx.restore();
}
function degToRad(d){ return d * Math.PI/180; }

// animation using requestAnimationFrame for smooth spin
function openRoulette(info, idx){
  rouletteOverlay.classList.add('show');
  rouletteOverlay.setAttribute('aria-hidden','false');
  rouletteResult.textContent = '';
  drawWheel(0);

  // Spin params
  const minTurns = 3; // минимум оборотов
  const maxTurns = 6;
  const turns = Math.random()*(maxTurns-minTurns)+minTurns;
  // final angle such that pointer (0 deg) will land somewhere random
  // but we want true randomness: compute final rotation (deg)
  const finalDeg = Math.random()*360 + turns*360;
  const duration = 3500 + Math.random()*800; // 3.5–4.3s

  const start = performance.now();
  const startAngle = 0;
  const endAngle = finalDeg;

  function easeOutCubic(t){ return 1 - Math.pow(1 - t, 3); }

  function frame(now){
    const elapsed = now - start;
    const t = Math.min(1, elapsed/duration);
    const eased = easeOutCubic(t);
    const curAngle = startAngle + (endAngle - startAngle)*eased;
    // draw rotated wheel so that sector moves under stationary pointer at top
    drawWheel(curAngle % 360);
    if(t < 1){
      requestAnimationFrame(frame);
    } else {
      // stop and determine result — pointer at 0 deg => wheel angle mod360
      const finalAngleMod = (curAngle % 360);
      // because we rotated wheel by curAngle, the sector at top (pointer) corresponds to angle = (360 - finalAngleMod) mod360
      const pointerAngle = (360 - finalAngleMod) % 360;
      // green is 0..GREEN_ANGLE
      const win = (pointerAngle >= 0 && pointerAngle <= GREEN_ANGLE);
      finalizeRoulette(win, info, idx);
    }
  }
  requestAnimationFrame(frame);
}

function finalizeRoulette(win, info, idx){
  if(win){
    // multiply by 2
    info.value = info.value * 2;
    currentValue = info.value;
    // update displayed number in cell
    const cellEl = gridEl.children[idx];
    if(cellEl){
      animateCellNumber(cellEl, info.value);
      cellEl.classList.add('reward','opened');
    }
    rouletteResult.textContent = `Удача — ×2! Сейчас: ${info.value}`;
    rouletteResult.style.color = '#7fffb2';
  } else {
    // burn
    info.value = 0;
    currentValue = 0;
    const cellEl = gridEl.children[idx];
    if(cellEl){
      cellEl.textContent = '0';
      cellEl.classList.remove('reward');
      cellEl.classList.add('opened');
    }
    // also mark logical opened? we'll reset so player can click later
    rouletteResult.textContent = `Печально — награда сгорела.`;
    rouletteResult.style.color = '#ff9b9b';
  }
  // disable upgrade if burnt
  upgradeBtn.disabled = (currentValue===0);
  if(currentValue>0) upgradeBtn.setAttribute('data-current', String(currentValue));
  else upgradeBtn.removeAttribute('data-current');
}

// close roulette
closeRoulette.addEventListener('click', ()=>{
  rouletteOverlay.classList.remove('show');
  rouletteOverlay.setAttribute('aria-hidden','true');
  // if burned, reset that cell to closed state (as user asked earlier maybe)
  if(currentCellIndex!==null){
    const info = board[currentCellIndex];
    if(info && info.type==='reward' && info.value===0){
      // reset cell to closed so it's clickable again
      const el = gridEl.children[currentCellIndex];
      if(el){
        el.classList.remove('opened','reward');
        el.textContent = '';
        board[currentCellIndex].opened = false;
        currentCellIndex = null;
      }
    }
  }
});

/* =========== инициализация =========== */

generateBoard();

/* ====== небольшая доработка: при генерации будем показывать 1 макс и баланс бомб ====== */

/* ====================================== */

</script>
</body>
</html>
