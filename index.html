<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>EXTRIM Miner ‚Äî –≥–æ—Ç–æ–≤–æ</title>
<style>
  :root{
    --accent: #ffd700;
    --dark: rgba(0,0,0,0.6);
  }
  html,body{height:100%;margin:0;font-family:Inter,Segoe UI,Arial, sans-serif;background:#111;}
  body{
    background: url('extrim.png') no-repeat center center fixed;
    background-size: cover;
    color:#fff;
    display:flex;
    align-items:flex-start;
    justify-content:center;
    padding:24px;
    box-sizing:border-box;
  }
  /* –∑–∞—Ç–µ–º–Ω—ë–Ω–Ω—ã–π —Ñ–æ–Ω –¥–ª—è —á–∏—Ç–∞–µ–º–æ—Å—Ç–∏ */
  body::before{
    content:""; position:fixed; inset:0;
    background:var(--dark); backdrop-filter:blur(4px);
    z-index:0;
  }

  .app{
    z-index:1;
    width:100%;
    max-width:980px;
    display:flex;
    flex-direction:column;
    align-items:center;
  }

  header{
    width:100%;
    display:flex;
    align-items:center;
    justify-content:space-between;
    gap:12px;
    margin-bottom:16px;
  }
  h1{margin:0;font-size:28px; font-weight:700; text-shadow:0 2px 8px rgba(0,0,0,0.6);}
  .top-controls{
    position:relative;
    display:flex;
    align-items:center;
    gap:8px;
  }
  .mode-btn{
    padding:9px 16px;
    border-radius:999px;
    border:none;
    font-weight:700;
    cursor:pointer;
    background:rgba(255,215,0,0.85);
    color:#000;
    box-shadow:0 6px 18px rgba(0,0,0,0.4);
  }
  .mode-btn.inactive{
    background:rgba(255,255,255,0.12);
    color:#fff;
    box-shadow:none;
  }

  /* —Ü–µ–Ω—Ç—Ä ‚Äî –ø–æ–ª–µ */
  .center{
    display:flex;
    flex-direction:column;
    align-items:center;
    gap:14px;
    width:100%;
  }

  .grid{
    display:grid;
    grid-template-columns:repeat(8,72px);
    grid-auto-rows:72px;
    gap:10px;
    background:rgba(0,0,0,0.45);
    padding:18px;
    border-radius:14px;
    box-shadow:0 10px 40px rgba(0,0,0,0.6);
  }

  .cell{
    background:linear-gradient(#ffffff,#f2f2f2);
    border-radius:12px;
    border:2px solid rgba(0,0,0,0.15);
    display:flex;
    align-items:center;
    justify-content:center;
    font-weight:800;
    color:#111;
    font-size:18px;
    user-select:none;
    cursor:pointer;
    box-shadow:0 4px 8px rgba(0,0,0,0.2);
    transform:translateZ(0);
    transition:transform .12s ease, box-shadow .12s ease, background .12s ease;
  }
  .cell:hover{ transform:translateY(-6px) scale(1.03); box-shadow:0 12px 20px rgba(0,0,0,0.35);}
  .cell.opened{ background:#efefef; cursor:default; transform:none; box-shadow:0 2px 6px rgba(0,0,0,0.15); }
  .cell.bomb{ background:#c62828; color:white; font-size:22px; box-shadow:0 0 10px #ff3d3d; }
  .cell.reward{ color:#0b833e; text-shadow:0 0 6px rgba(75,175,90,0.25); }

  .controls {
    display:flex;
    gap:12px;
    align-items:center;
    justify-content:center;
    margin-top:6px;
  }
  #upgradeBtn{
    padding:12px 26px;
    border-radius:26px;
    border:none;
    background:linear-gradient(45deg,var(--accent),#ffab00);
    color:#000;
    font-weight:800;
    cursor:pointer;
    box-shadow:0 10px 30px rgba(255,200,0,0.18);
    display:inline-block;
  }
  #upgradeBtn[disabled]{
    opacity:.45; cursor:not-allowed; box-shadow:none;
  }

  .info-line{
    margin-top:10px;
    color:rgba(255,255,255,0.85);
    font-size:14px;
  }

  /* –†—É–ª–µ—Ç–∫–∞ –æ–≤–µ—Ä–ª–µ–π */
  #rouletteOverlay{
    position:fixed; inset:0; display:flex; align-items:center; justify-content:center; z-index:9999;
    background:rgba(0,0,0,0.7); visibility:hidden; opacity:0; transition:opacity .25s ease;
  }
  #rouletteOverlay.show{ visibility:visible; opacity:1; }
  #rouletteBox{
    width:360px; max-width:92vw; background:linear-gradient(#161616,#222); border-radius:12px; padding:18px; text-align:center;
    box-shadow:0 30px 80px rgba(0,0,0,0.7);
  }
  #rouletteCanvas{ width:300px; height:300px; display:block; margin:0 auto; border-radius:50%; background:#111; }
  #rouletteArrow{
    width:0;height:0;border-left:14px solid transparent;border-right:14px solid transparent;border-bottom:26px solid var(--accent);
    margin:-12px auto 8px; filter:drop-shadow(0 4px 8px rgba(0,0,0,0.6));
  }
  #rouletteResult{ margin-top:12px; font-weight:800; font-size:18px; color:#fff; min-height:26px;}
  .close-btn{
    margin-top:12px; padding:10px 18px; border-radius:10px; border:none; font-weight:700; cursor:pointer; background:var(--accent);
  }

  /* –∞–¥–∞–ø—Ç–∏–≤ */
  @media (max-width:760px){
    .grid{grid-template-columns:repeat(8,44px); grid-auto-rows:44px; gap:6px; padding:12px;}
    .cell{font-size:14px;}
    #rouletteCanvas{width:220px;height:220px;}
  }

</style>
</head>
<body>
  <div class="app">
    <header>
      <h1>EXTRIM Miner</h1>
      <div class="top-controls">
        <button id="btnTwitch" class="mode-btn">Twitch</button>
        <button id="btnYouTube" class="mode-btn inactive">YouTube</button>
      </div>
    </header>

    <div class="center">
      <div id="status" class="info-line">–†–µ–∂–∏–º: <span id="modeText">Twitch (–º–∞–∫—Å–∏–º—É–º 5000)</span></div>
      <div class="grid" id="grid" aria-hidden="false"></div>

      <div class="controls">
        <button id="upgradeBtn" disabled>–£–ª—É—á—à–∏—Ç—å –Ω–∞–≥—Ä–∞–¥—É</button>
      </div>
      <div class="info-line" id="hint">–ù–∞–∂–º–∏ –Ω–∞ –ª—é–±—É—é –∫–ª–µ—Ç–∫—É ‚Äî –æ—Ç–∫—Ä–æ—é—Ç—Å—è –≤—Å–µ —Å—É–º–º—ã, –±–æ–º–±—ã –æ—Å—Ç–∞—é—Ç—Å—è —Å–∫—Ä—ã—Ç—ã–º–∏ –¥–æ –∫–ª–∏–∫–∞.</div>
    </div>
  </div>

  <!-- –†—É–ª–µ—Ç–∫–∞ -->
  <div id="rouletteOverlay" role="dialog" aria-hidden="true">
    <div id="rouletteBox">
      <div id="rouletteArrow"></div>
      <canvas id="rouletteCanvas" width="300" height="300"></canvas>
      <div id="rouletteResult"></div>
      <button id="closeRoulette" class="close-btn">–ó–∞–∫—Ä—ã—Ç—å</button>
    </div>
  </div>

<script>
/* ===========================================================
   –ù–∞—Å—Ç—Ä–æ–π–∫–∏ –∏ –ª–æ–≥–∏–∫–∞ –∏–≥—Ä—ã
   =========================================================== */

const gridEl = document.getElementById('grid');
const btnTwitch = document.getElementById('btnTwitch');
const btnYouTube = document.getElementById('btnYouTube');
const modeText = document.getElementById('modeText');
const upgradeBtn = document.getElementById('upgradeBtn');
const statusLine = document.getElementById('status');
const rouletteOverlay = document.getElementById('rouletteOverlay');
const rouletteCanvas = document.getElementById('rouletteCanvas');
const rouletteResult = document.getElementById('rouletteResult');
const closeRoulette = document.getElementById('closeRoulette');

let mode = 'twitch'; // 'twitch' –∏–ª–∏ 'youtube'
let board = []; // –º–∞—Å—Å–∏–≤ 64 –æ–±—ä–µ–∫—Ç–æ–≤ {type:'bomb'|'reward', value:number, opened:boolean}
let firstClickDone = false;
let currentCellIndex = null;
let currentValue = 0;
const BOMBS_COUNT = 10;
const SIZE = 64; // 8x8

// –ù–∞–≥—Ä–∞–¥—ã –¥–ª—è —Ä–µ–∂–∏–º–æ–≤
const twitchRewards = [
  {value:1000, weight:40},
  {value:1500, weight:30},
  {value:2000, weight:15},
  {value:2500, weight:8},
  {value:5000, weight:5},
];

const youtubeRewards = [
  {value:1000, weight:35},
  {value:1500, weight:25},
  {value:2000, weight:15},
  {value:2500, weight:10},
  {value:5000, weight:8},
  {value:10000, weight:7},
];

// –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω–∞—è ‚Äî –≤—ã–±–æ—Ä –ø–æ –≤–µ—Å–∞–º
function weightedRandom(items){
  const total = items.reduce((s,i)=>s+i.weight,0);
  let r = Math.random()*total;
  for(const it of items){
    if(r < it.weight) return it.value;
    r -= it.weight;
  }
  return items[items.length-1].value;
}

// –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –¥–æ—Å–∫–∏ ‚Äî –∫–ª–∞–¥—ë–º –±–æ–º–±—ã –∏ –Ω–∞–≥—Ä–∞–¥—ã, –≥–∞—Ä–∞–Ω—Ç–∏—Ä—É–µ–º 1 –º–∞–∫—Å.
function generateBoard(){
  board = new Array(SIZE).fill(null);
  // –≤—ã–±–µ—Ä–µ–º BOMBS_COUNT —É–Ω–∏–∫–∞–ª—å–Ω—ã—Ö –ø–æ–∑–∏—Ü–∏–π
  const idxs = [...Array(SIZE).keys()];
  shuffleArray(idxs);

  const bombPos = new Set(idxs.slice(0,BOMBS_COUNT));
  // –ø—Ä–∏—Å–≤–∞–∏–≤–∞–µ–º
  for(let i=0;i<SIZE;i++){
    if(bombPos.has(i)){
      board[i] = {type:'bomb', value:0, opened:false};
    } else {
      board[i] = {type:'reward', value:0, opened:false};
    }
  }
  // —Ç–µ–ø–µ—Ä—å —Ä–∞—Å–ø—Ä–µ–¥–µ–ª–∏–º –∑–Ω–∞—á–µ–Ω–∏—è –Ω–∞–≥—Ä–∞–¥
  const rewardList = (mode==='twitch') ? twitchRewards : youtubeRewards;

  // —Å–Ω–∞—á–∞–ª–∞ –ø–æ—Å—Ç–∞–≤–∏–º –≥–∞—Ä–∞–Ω—Ç–∏—Ä–æ–≤–∞–Ω–Ω—É—é –º–∞–∫—Å–∏–º–∞–ª—å–Ω—É—é —Å—É–º–º—É –Ω–∞ —Å–ª—É—á–∞–π–Ω–æ–π –Ω–µ-–±–æ–º–±–µ
  const maxVal = (mode==='twitch')?5000:10000;
  const freeIdx = [];
  for(let i=0;i<SIZE;i++) if(board[i].type==='reward') freeIdx.push(i);
  shuffleArray(freeIdx);
  if(freeIdx.length>0){
    board[freeIdx[0]].value = maxVal;
  }

  // –¥–ª—è –æ—Å—Ç–∞–ª—å–Ω—ã—Ö reward cell ‚Äî –∑–∞–ø–æ–ª–Ω–∏–º –≤–µ—Å–∞–º–∏
  for(let i=0;i<SIZE;i++){
    if(board[i].type==='reward' && board[i].value===0){
      board[i].value = weightedRandom(rewardList);
    }
  }

  firstClickDone = false;
  currentCellIndex = null;
  currentValue = 0;
  renderBoardCollapsed();
  upgradeBtn.disabled = true;
  upgradeBtn.removeAttribute('data-current');
}

// –ü–æ–º–µ—â–∞–µ–º —Å–∫—Ä—ã—Ç—ã–π —Ä–µ–Ω–¥–µ—Ä (–ø—É—Å—Ç—ã–µ –ø–ª–∏—Ç–∫–∏) ‚Äî –ø–æ–∫–∞ –Ω–µ —Ä–∞—Å–∫—Ä—ã—Ç–æ
function renderBoardCollapsed(){
  gridEl.innerHTML = '';
  for(let i=0;i<SIZE;i++){
    const cell = document.createElement('div');
    cell.className = 'cell';
    cell.dataset.index = i;
    cell.innerHTML = ''; // –ø—É—Å—Ç–æ
    cell.addEventListener('click', onCellClick);
    gridEl.appendChild(cell);
  }
}

// –ü–æ–ª–Ω–æ–µ —Ä–∞—Å–∫—Ä—ã—Ç–∏–µ —Å—É–º–º (–ø–æ–∫–∞–∑—ã–≤–∞–µ–º —á–∏—Å–ª–∞, –Ω–æ –±–æ–º–±—ã –æ—Å—Ç–∞—é—Ç—Å—è —Å–∫—Ä—ã—Ç—ã)
function revealAllSums(){
  const cells = gridEl.children;
  for(let i=0;i<SIZE;i++){
    const info = board[i];
    const el = cells[i];
    if(info.type==='reward'){
      el.classList.add('opened','reward');
      animateCellNumber(el, info.value);
    } else {
      // –±–æ–º–±—ã –æ—Å—Ç–∞—é—Ç—Å—è –∑–∞–∫—Ä—ã—Ç—ã (–ø—É—Å—Ç—ã–º–∏)
      el.classList.remove('opened');
      el.textContent = '';
    }
    // mark opened state logically? we only visually show sums
    // board[i].opened stays false until clicked
  }
}

// –ö–ª–∏–∫–µ –ø–æ —è—á–µ–π–∫–µ
function onCellClick(e){
  const idx = Number(e.currentTarget.dataset.index);
  if(board[idx].opened) return; // —É–∂–µ –æ–∫–æ–Ω—á–∞—Ç–µ–ª—å–Ω–æ –æ—Ç–∫—Ä—ã—Ç–æ (–ø–æ—Å–ª–µ –±–æ–º–±—ã –∏–ª–∏ —É–∂–µ –≤—ã–±—Ä–∞–Ω–Ω–∞—è)
  // –µ—Å–ª–∏ –ø–µ—Ä–≤—ã–π –∫–ª–∏–∫ ‚Äî —Ä–∞—Å–∫—Ä—ã–≤–∞–µ–º –≤—Å–µ —Å—É–º–º—ã (–∫–∞–∫ –ø—Ä–æ—Å–∏–ª)
  if(!firstClickDone){
    firstClickDone = true;
    revealAllSums();
  }
  // —Ç–µ–ø–µ—Ä—å –æ–±—Ä–∞–±–æ—Ç–∞–µ–º –∫–ª–∏–∫ –ø–æ –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–π —è—á–µ–π–∫–µ
  const info = board[idx];
  const el = e.currentTarget;
  if(info.type === 'bomb'){
    // –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –≤–∑—Ä—ã–≤
    el.classList.add('bomb','opened');
    el.textContent = 'üí£';
    board[idx].opened = true;
    // —Å–±—Ä–∞—Å—ã–≤–∞–µ–º —Ç–µ–∫—É—â—É—é –Ω–∞–≥—Ä–∞–¥—É
    currentCellIndex = null;
    currentValue = 0;
    upgradeBtn.disabled = true;
    upgradeBtn.removeAttribute('data-current');
    return;
  } else {
    // –ø–æ–∫–∞–∑—ã–≤–∞–µ–º reward (–µ—Å–ª–∏ –µ—â–µ –Ω–µ –ø–æ–∫–∞–∑–∞–Ω –∫–∞–∫ opened)
    el.classList.add('opened','reward');
    animateCellNumber(el, info.value);
    board[idx].opened = true;
    currentCellIndex = idx;
    currentValue = info.value;
    upgradeBtn.disabled = false;
    upgradeBtn.setAttribute('data-current', String(currentValue));
  }
}

// –ø–ª–∞–≤–Ω–∞—è –∞–Ω–∏–º–∞—Ü–∏—è —á–∏—Å–ª–∞ –≤ —è—á–µ–π–∫–µ
function animateCellNumber(el, target){
  let cur = parseInt(el.textContent.replace(/\D/g,'')) || 0;
  const steps = 24;
  const step = Math.max(1, Math.round((target - cur)/steps));
  const id = setInterval(()=>{
    cur += step;
    if(cur >= target){
      el.textContent = target;
      clearInterval(id);
    } else {
      el.textContent = cur;
    }
  }, 30);
}

// —É—Ç–∏–ª–∏—Ç–∞
function shuffleArray(a){
  for(let i=a.length-1;i>0;i--){
    const j = Math.floor(Math.random()*(i+1));
    [a[i],a[j]]=[a[j],a[i]];
  }
}

/* ============= –ø–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏–µ —Ä–µ–∂–∏–º–∞ ============= */
btnTwitch.addEventListener('click', ()=>{
  if(mode==='twitch') return;
  mode='twitch';
  btnTwitch.classList.remove('inactive');
  btnYouTube.classList.add('inactive');
  modeText.textContent = 'Twitch (–º–∞–∫—Å–∏–º—É–º 5000)';
  generateBoard();
});
btnYouTube.addEventListener('click', ()=>{
  if(mode==='youtube') return;
  mode='youtube';
  btnYouTube.classList.remove('inactive');
  btnTwitch.classList.add('inactive');
  modeText.textContent = 'YouTube (–º–∞–∫—Å–∏–º—É–º 10000)';
  generateBoard();
});

/* ============== Upgrade -> —Ä—É–ª–µ—Ç–∫–∞ =============== */

upgradeBtn.addEventListener('click', ()=>{
  if(currentCellIndex===null) return;
  // –±–µ—Ä–µ–º —Ç–µ–∫—É—â—É—é —Å—É–º–º—É
  const info = board[currentCellIndex];
  if(!info || info.type!=='reward') return;
  // –æ—Ç–∫—Ä—ã–≤–∞–µ–º –æ–≤–µ—Ä–ª–µ–π —Ä—É–ª–µ—Ç–∫–∏
  openRoulette(info, currentCellIndex);
});

/* ------------- —Ä—É–ª–µ—Ç–∫–∞ (–ø–ª–∞–≤–Ω–æ–µ –≤—Ä–∞—â–µ–Ω–∏–µ) ----------- */

const ctx = rouletteCanvas.getContext('2d');
const R = rouletteCanvas.width/2;
const GREEN_ANGLE = 120; // degrees of green sector
const RED_ANGLE = 360 - GREEN_ANGLE;
// draw static wheel initially
function drawWheel(angleOffset=0){
  const cx = rouletteCanvas.width/2;
  const cy = rouletteCanvas.height/2;
  ctx.clearRect(0,0,rouletteCanvas.width,rouletteCanvas.height);
  ctx.save();
  ctx.translate(cx,cy);
  ctx.rotate((angleOffset*Math.PI)/180);
  // green sector
  ctx.beginPath();
  ctx.moveTo(0,0);
  ctx.arc(0,0,R, degToRad(0), degToRad(GREEN_ANGLE));
  ctx.closePath();
  ctx.fillStyle = '#4caf50';
  ctx.fill();
  // red sector
  ctx.beginPath();
  ctx.moveTo(0,0);
  ctx.arc(0,0,R, degToRad(GREEN_ANGLE), degToRad(360));
  ctx.closePath();
  ctx.fillStyle = '#f44336';
  ctx.fill();
  // border
  ctx.beginPath();
  ctx.arc(0,0,R,0,Math.PI*2);
  ctx.lineWidth=4;
  ctx.strokeStyle='#ffd700';
  ctx.stroke();
  ctx.restore();
}
function degToRad(d){ return d * Math.PI/180; }

// animation using requestAnimationFrame for smooth spin
function openRoulette(info, idx){
  rouletteOverlay.classList.add('show');
  rouletteOverlay.setAttribute('aria-hidden','false');
  rouletteResult.textContent = '';
  drawWheel(0);

  // Spin params
  const minTurns = 3; // –º–∏–Ω–∏–º—É–º –æ–±–æ—Ä–æ—Ç–æ–≤
  const maxTurns = 6;
  const turns = Math.random()*(maxTurns-minTurns)+minTurns;
  // final angle such that pointer (0 deg) will land somewhere random
  // but we want true randomness: compute final rotation (deg)
  const finalDeg = Math.random()*360 + turns*360;
  const duration = 3500 + Math.random()*800; // 3.5‚Äì4.3s

  const start = performance.now();
  const startAngle = 0;
  const endAngle = finalDeg;

  function easeOutCubic(t){ return 1 - Math.pow(1 - t, 3); }

  function frame(now){
    const elapsed = now - start;
    const t = Math.min(1, elapsed/duration);
    const eased = easeOutCubic(t);
    const curAngle = startAngle + (endAngle - startAngle)*eased;
    // draw rotated wheel so that sector moves under stationary pointer at top
    drawWheel(curAngle % 360);
    if(t < 1){
      requestAnimationFrame(frame);
    } else {
      // stop and determine result ‚Äî pointer at 0 deg => wheel angle mod360
      const finalAngleMod = (curAngle % 360);
      // because we rotated wheel by curAngle, the sector at top (pointer) corresponds to angle = (360 - finalAngleMod) mod360
      const pointerAngle = (360 - finalAngleMod) % 360;
      // green is 0..GREEN_ANGLE
      const win = (pointerAngle >= 0 && pointerAngle <= GREEN_ANGLE);
      finalizeRoulette(win, info, idx);
    }
  }
  requestAnimationFrame(frame);
}

function finalizeRoulette(win, info, idx){
  if(win){
    // multiply by 2
    info.value = info.value * 2;
    currentValue = info.value;
    // update displayed number in cell
    const cellEl = gridEl.children[idx];
    if(cellEl){
      animateCellNumber(cellEl, info.value);
      cellEl.classList.add('reward','opened');
    }
    rouletteResult.textContent = `–£–¥–∞—á–∞ ‚Äî √ó2! –°–µ–π—á–∞—Å: ${info.value}`;
    rouletteResult.style.color = '#7fffb2';
  } else {
    // burn
    info.value = 0;
    currentValue = 0;
    const cellEl = gridEl.children[idx];
    if(cellEl){
      cellEl.textContent = '0';
      cellEl.classList.remove('reward');
      cellEl.classList.add('opened');
    }
    // also mark logical opened? we'll reset so player can click later
    rouletteResult.textContent = `–ü–µ—á–∞–ª—å–Ω–æ ‚Äî –Ω–∞–≥—Ä–∞–¥–∞ —Å–≥–æ—Ä–µ–ª–∞.`;
    rouletteResult.style.color = '#ff9b9b';
  }
  // disable upgrade if burnt
  upgradeBtn.disabled = (currentValue===0);
  if(currentValue>0) upgradeBtn.setAttribute('data-current', String(currentValue));
  else upgradeBtn.removeAttribute('data-current');
}

// close roulette
closeRoulette.addEventListener('click', ()=>{
  rouletteOverlay.classList.remove('show');
  rouletteOverlay.setAttribute('aria-hidden','true');
  // if burned, reset that cell to closed state (as user asked earlier maybe)
  if(currentCellIndex!==null){
    const info = board[currentCellIndex];
    if(info && info.type==='reward' && info.value===0){
      // reset cell to closed so it's clickable again
      const el = gridEl.children[currentCellIndex];
      if(el){
        el.classList.remove('opened','reward');
        el.textContent = '';
        board[currentCellIndex].opened = false;
        currentCellIndex = null;
      }
    }
  }
});

/* =========== –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è =========== */

generateBoard();

/* ====== –Ω–µ–±–æ–ª—å—à–∞—è –¥–æ—Ä–∞–±–æ—Ç–∫–∞: –ø—Ä–∏ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –±—É–¥–µ–º –ø–æ–∫–∞–∑—ã–≤–∞—Ç—å 1 –º–∞–∫—Å –∏ –±–∞–ª–∞–Ω—Å –±–æ–º–± ====== */

/* ====================================== */

</script>
</body>
</html>
