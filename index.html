<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>EXTRIM Miner - –û–±–Ω–æ–≤–ª–µ–Ω–Ω–∞—è –≤–µ—Ä—Å–∏—è</title>
<style>
  body {
    margin: 0;
    font-family: Arial, sans-serif;
    background: url('extrim.png') no-repeat center center fixed;
    background-size: cover;
    color: white;
    display: flex;
    flex-direction: column;
    align-items: center;
    min-height: 100vh;
    padding: 20px;
  }
  h1 {
    background: rgba(0,0,0,0.5);
    padding: 10px 20px;
    border-radius: 10px;
    margin-bottom: 20px;
  }
  #grid {
    display: grid;
    grid-template-columns: repeat(8, 60px);
    grid-template-rows: repeat(8, 60px);
    gap: 6px;
  }
  .cell {
    background: rgba(255,255,255,0.2);
    border: 2px solid rgba(255,255,255,0.5);
    cursor: pointer;
    font-weight: bold;
    font-size: 18px;
    display: flex;
    justify-content: center;
    align-items: center;
    user-select: none;
    transition: background-color 0.3s, transform 0.2s;
    color: white;
  }
  .cell:hover:not(.opened) {
    background-color: rgba(255,255,255,0.35);
    transform: scale(1.05);
  }
  .opened {
    cursor: default;
    background-color: rgba(0,0,0,0.7);
  }
  .selected {
    background-color: rgba(255,0,0,0.7);
  }
  .bomb {
    animation: bombFlash 0.6s infinite alternate;
  }
  @keyframes bombFlash {
    from { background-color: rgba(255, 0, 0, 0.7); }
    to { background-color: rgba(150, 0, 0, 0.9); }
  }
  #showAllBtn, #upgradeBtn {
    margin-top: 20px;
    padding: 12px 25px;
    font-size: 18px;
    border: none;
    border-radius: 6px;
    font-weight: bold;
    cursor: pointer;
    background: linear-gradient(45deg, #FFD700, #FFA500);
    color: black;
    user-select: none;
    box-shadow: 0 0 8px #FFD700;
    transition: background 0.3s ease, box-shadow 0.3s ease;
  }
  #showAllBtn:hover, #upgradeBtn:hover {
    background: linear-gradient(45deg, #FFA500, #FFD700);
    box-shadow: 0 0 14px #FFA500;
  }
  #upgradeBtn {
    margin-left: 10px;
  }
  #upgradeBtn:disabled {
    background: #666;
    box-shadow: none;
    cursor: not-allowed;
  }
  #controls {
    margin-top: 15px;
    display: flex;
    justify-content: center;
    gap: 10px;
  }
  /* –†—É–ª–µ—Ç–∫–∞ */
  #rouletteContainer {
    margin-top: 30px;
    width: 300px;
    height: 300px;
    position: relative;
  }
  #roulette {
    width: 100%;
    height: 100%;
    border-radius: 50%;
    border: 6px solid gold;
    position: relative;
    overflow: hidden;
  }
  #arrow {
    position: absolute;
    top: -20px;
    left: 50%;
    transform: translateX(-50%);
    width: 0; 
    height: 0; 
    border-left: 20px solid transparent;
    border-right: 20px solid transparent;
    border-bottom: 30px solid red;
    z-index: 10;
  }
  /* –ò—Å—Ç–æ—á–Ω–∏–∫ –∫–Ω–æ–ø–æ–∫ */
  #sourceButtons {
    margin-bottom: 20px;
    display: flex;
    gap: 15px;
  }
  #sourceButtons button {
    padding: 10px 20px;
    font-size: 16px;
    cursor: pointer;
    font-weight: bold;
    border-radius: 6px;
    border: none;
    background: linear-gradient(45deg, #FFD700, #FFA500);
    color: black;
    box-shadow: 0 0 8px #FFD700;
    transition: background 0.3s ease, box-shadow 0.3s ease;
  }
  #sourceButtons button:hover:not(:disabled) {
    background: linear-gradient(45deg, #FFA500, #FFD700);
    box-shadow: 0 0 14px #FFA500;
  }
  #sourceButtons button:disabled {
    background: #666;
    box-shadow: none;
    cursor: not-allowed;
  }
</style>
</head>
<body>

<h1>EXTRIM Miner</h1>

<div id="sourceButtons">
  <button id="twitchBtn" disabled>Twitch</button>
  <button id="youtubeBtn">YouTube</button>
</div>

<div id="grid"></div>

<div id="controls" style="display:none;">
  <button id="showAllBtn">–ü–æ–∫–∞–∑–∞—Ç—å —Å–∫—Ä—ã—Ç—ã–µ —è—á–µ–π–∫–∏</button>
  <button id="upgradeBtn">–£–ª—É—á—à–∏—Ç—å –Ω–∞–≥—Ä–∞–¥—É</button>
</div>

<div id="rouletteContainer" style="display:none;">
  <div id="arrow"></div>
  <canvas id="roulette" width="300" height="300"></canvas>
</div>

<script>
  const grid = document.getElementById('grid');
  const showAllBtn = document.getElementById('showAllBtn');
  const upgradeBtn = document.getElementById('upgradeBtn');
  const controls = document.getElementById('controls');
  const rouletteContainer = document.getElementById('rouletteContainer');
  const rouletteCanvas = document.getElementById('roulette');
  const ctx = rouletteCanvas.getContext('2d');

  const twitchBtn = document.getElementById('twitchBtn');
  const youtubeBtn = document.getElementById('youtubeBtn');

  const ROWS = 8;
  const COLS = 8;
  const TOTAL_CELLS = ROWS * COLS;

  const twitchValues = [
    {value: 1000, weight: 30},
    {value: 1500, weight: 25},
    {value: 2000, weight: 20},
    {value: 2500, weight: 15},
    {value: 5000, weight: 8},
  ];

  const youtubeValues = [
    {value: 1000, weight: 30},
    {value: 1500, weight: 25},
    {value: 2000, weight: 20},
    {value: 2500, weight: 15},
    {value: 5000, weight: 8},
    {value: 10000, weight: 2},
  ];

  let currentSource = 'twitch';
  const bombChance = 0.2;

  let cellsData = [];
  let selectedIndex = null;
  let currentReward = 0;
  let rouletteSpinning = false;

  function weightedRandom(weights) {
    const sum = weights.reduce((acc, cur) => acc + cur.weight, 0);
    let rnd = Math.random() * sum;
    for (const item of weights) {
      if (rnd < item.weight) return item.value;
      rnd -= item.weight;
    }
    return weights[weights.length -1].value;
  }

  function generateCells() {
    cellsData = [];
    const guaranteedIndex = Math.floor(Math.random() * TOTAL_CELLS);
    for(let i=0; i<TOTAL_CELLS; i++) {
      if(i === guaranteedIndex) {
        cellsData[i] = { type: 'reward', value: 5000 };
        continue;
      }
      if(Math.random() < bombChance) {
        cellsData[i] = { type: 'bomb' };
      } else {
        let vals = currentSource === 'twitch' ? twitchValues : youtubeValues;
        let val = weightedRandom(vals);
        cellsData[i] = { type: 'reward', value: val };
      }
    }
  }

  function createGrid() {
    grid.innerHTML = '';
    for(let i=0; i<TOTAL_CELLS; i++) {
      const cell = document.createElement('div');
      cell.classList.add('cell');
      cell.dataset.index = i;
      cell.textContent = '';
      cell.addEventListener('click', () => onCellClick(i, cell));
      grid.appendChild(cell);
    }
  }

  function openCell(i, cell) {
    const data = cellsData[i];
    cell.classList.add('opened');
    if(data.type === 'bomb') {
      cell.textContent = 'üí£';
      cell.classList.add('bomb');
    } else {
      animateNumber(cell, data.value);
    }
  }

  function animateNumber(cell, target) {
    let value = parseInt(cell.textContent) || 0;
    let start = value;
    let diff = target - start;
    let duration = 600;
    let startTime = null;

    function step(timestamp) {
      if(!startTime) startTime = timestamp;
      let progress = timestamp - startTime;
      let percent = Math.min(progress / duration, 1);
      let current = Math.floor(start + diff * percent);
      cell.textContent = current;
      if(percent < 1) {
        requestAnimationFrame(step);
      } else {
        cell.textContent = target;
      }
    }
    requestAnimationFrame(step);
  }

  function onCellClick(i, cell) {
    if(selectedIndex !== null) return;
    openCell(i, cell);
    selectedIndex = i;
    currentReward = cellsData[i].type === 'reward' ? cellsData[i].value : 0;
    cell.classList.add('selected');
    controls.style.display = 'flex';
    showAllBtn.style.display = 'inline-block';
    upgradeBtn.style.display = cellsData[i].type === 'reward' ? 'inline-block' : 'none';
  }

  function showAllCells() {
    const cells = document.querySelectorAll('.cell');
    cells.forEach((cell, idx) => {
      if(idx === selectedIndex) return;
      openCell(idx, cell);
    });
    showAllBtn.style.display = 'none';
  }

  // –†—É–ª–µ—Ç–∫–∞ setup
  const segments = [
    {color: 'green', label: 'x2', multiplier: 2},
    {color: 'red', label: '–°–≥–æ—Ä–µ–ª–æ', multiplier: 0},
    {color: 'green', label: 'x2', multiplier: 2},
    {color: 'red', label: '–°–≥–æ—Ä–µ–ª–æ', multiplier: 0},
    {color: 'green', label: 'x2', multiplier: 2},
    {color: 'red', label: '–°–≥–æ—Ä–µ–ª–æ', multiplier: 0},
  ];
  const segmentCount = segments.length;
  const segmentAngle = (2 * Math.PI) / segmentCount;

  let rouletteAngle = 0;
  let spinning = false;
  let spinStartTime = null;
  let spinDuration = 4000;
  let finalSegmentIndex = null;

  function drawRoulette() {
    const radius = rouletteCanvas.width / 2;
    ctx.clearRect(0, 0, rouletteCanvas.width, rouletteCanvas.height);
    ctx.save();
    ctx.translate(radius, radius);
    ctx.rotate(rouletteAngle);

    for(let i=0; i < segmentCount; i++) {
      const seg = segments[i];
      ctx.beginPath();
      ctx.fillStyle = seg.color;
      ctx.moveTo(0,0);
      ctx.arc(0, 0, radius, i*segmentAngle, (i+1)*segmentAngle);
      ctx.lineTo(0,0);
      ctx.fill();

      ctx.fillStyle = 'black';
      ctx.font = 'bold 20px Arial';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      const textAngle = i*segmentAngle + segmentAngle/2;
      const textX = Math.cos(textAngle) * radius * 0.6;
      const textY = Math.sin(textAngle) * radius * 0.6;
      ctx.fillText(seg.label, textX, textY);
    }

    ctx.restore();
  }

  function animateRoulette(timestamp) {
    if(!spinStartTime) spinStartTime = timestamp;
    const elapsed = timestamp - spinStartTime;

    const easeOut = t => 1 - Math.pow(1 - t, 3);
    let progress = Math.min(elapsed / spinDuration, 1);
    const easedProgress = easeOut(progress);

    const rotations = 6;
    const finalAngle = rotations * 2 * Math.PI + (segmentCount - finalSegmentIndex) * segmentAngle - segmentAngle/2;

    rouletteAngle = finalAngle * easedProgress;
    drawRoulette();

    if(progress < 1) {
      requestAnimationFrame(animateRoulette);
    } else {
      finishRoulette();
    }
  }

  function finishRoulette() {
    const cell = document.querySelector(`.cell[data-index='${selectedIndex}']`);
    if(!cell) return;

    const seg = segments[finalSegmentIndex];
    if(seg.multiplier === 2) {
      currentReward *= 2;
      animateNumber(cell, currentReward);
      alert('–ü–æ–∑–¥—Ä–∞–≤–ª—è–µ–º! –ù–∞–≥—Ä–∞–¥–∞ —É–¥–≤–æ–µ–Ω–∞!');
    } else {
      alert('–£–≤—ã, –Ω–∞–≥—Ä–∞–¥–∞ —Å–≥–æ—Ä–µ–ª–∞!');
      currentReward = 0;
      cell.textContent = '';
      cell.classList.remove('opened', 'selected', 'bomb');
      selectedIndex = null;
      controls.style.display = 'none';
    }
    rouletteContainer.style.display = 'none';
    upgradeBtn.disabled = false;
    rouletteSpinning = false;
  }

  function startRoulette() {
    if(rouletteSpinning) return;
    if(currentReward === 0) {
      alert('–ù–µ—Ç –Ω–∞–≥—Ä–∞–¥—ã –¥–ª—è —É–ª—É—á—à–µ–Ω–∏—è!');
      return;
    }
    rouletteSpinning = true;
    upgradeBtn.disabled = true;
    rouletteContainer.style.display = 'block';
    finalSegmentIndex = Math.floor(Math.random() * segmentCount);
    spinStartTime = null;
    requestAnimationFrame(animateRoulette);
  }

  twitchBtn.onclick = () => {
    currentSource = 'twitch';
    twitchBtn.disabled = true;
    youtubeBtn.disabled = false;
    initGame();
  };
  youtubeBtn.onclick = () => {
    currentSource = 'youtube';
    twitchBtn.disabled = false;
    youtubeBtn.disabled = true;
    initGame();
  };

  showAllBtn.onclick = () => showAllCells();
  upgradeBtn.onclick = () => startRoulette();

  function initGame() {
    selectedIndex = null;
    currentReward = 0;
    controls.style.display = 'none';
    rouletteContainer.style.display = 'none';
    upgradeBtn.disabled = false;
    generateCells();
    createGrid();
  }

  initGame();
</script>
</body>
</html>
